---
title: "expo动画002"
date: "2025-11-16T22:32:51+08:00"
tags: [expo, react-native, animation]
description: "使用 React Native Reanimated 和 Gesture Handler 实现可拖拽方块动画，支持手势交互和弹性回弹效果"
video:
  type: "cloudinary"
  url: "https://player.cloudinary.com/embed/?cloud_name=di0hcf6yr&public_id=blog-astro%2Fvideo%2Fexpo-002_ukuz0c&autoplay_mode=on-scroll&muted=true&loop=true"
---

import { CloudinaryVideo, Link } from "@/components";

<CloudinaryVideo url="https://player.cloudinary.com/embed/?cloud_name=di0hcf6yr&public_id=blog-astro%2Fvideo%2Fexpo-002_ukuz0c&autoplay_mode=on-scroll&muted=true&loop=true" />

<Link
  url="https://youtu.be/4HUreYYoE6U?si=1l6NvdQdu04HHs-x"
  icon="youtube"
  title="YouTube"
/>

## 目录

## 代码概述

这是一个使用 **React Native Reanimated** 和 **React Native Gesture Handler** 的 Expo 动画示例，实现了一个可拖拽的蓝色方块。当方块被拖拽到圆圈边界内并释放时，会自动使用弹性动画回到中心位置。

## 主要功能

### 1. **导入依赖** (25-37 行)

- `expo-router` 的 `Stack`：用于导航配置
- `react-native`：基础组件（Dimensions, StyleSheet, View）
- `react-native-gesture-handler`：手势处理库
  - `Gesture`：手势对象
  - `GestureDetector`：手势检测器组件
  - `GestureHandlerRootView`：手势处理根视图
- `react-native-reanimated`：动画库
  - `useAnimatedStyle`：创建动画样式
  - `useSharedValue`：创建共享的动画值
  - `withSpring`：弹性动画函数

### 2. **常量定义** (39-43 行)

- `SIZE = 100`：方块的大小（宽高）
- `CIRCLE_RADIUS = SIZE * 2`：圆圈的半径（200）
- `CIRCLE_VISIBLE_RADIUS`：圆圈的实际可视半径（150）
- `width, height`：获取屏幕尺寸

### 3. **工具函数** (45-54 行)

**clamp 函数** (45-49 行)

```jsx
function clamp(val: number, min: number, max: number): number {
  "worklet";
  return Math.min(Math.max(val, min), max);
}
```

- 限制值在指定范围内
- `"worklet"` 标记使其在 UI 线程运行

**distance 函数** (51-54 行)

```jsx
function distance(x: number, y: number): number {
  "worklet";
  return Math.sqrt(x ** 2 + y ** 2);
}
```

- 计算两点间的欧几里得距离（用于判断方块是否在圆圈内）

### 4. **核心动画逻辑**

**共享值** (57-60 行)

- `translateX`、`translateY`：当前方块的位置
- `prevTranslateX`、`prevTranslateY`：拖拽开始时的位置

**手势处理** (62-91 行)

- `onStart`：记录拖拽开始时的位置
- `onUpdate`：更新方块位置，使用 `clamp` 限制在屏幕范围内
- `onEnd`：检查方块是否在圆圈内，如果是则使用 `withSpring` 动画回到中心

**动画样式** (93-104 行)

- 使用 `useAnimatedStyle` 创建基于 `translateX` 和 `translateY` 的变换样式

### 5. **UI 渲染** (105-120 行)

- 隐藏导航栏
- 使用 `GestureHandlerRootView` 包裹整个视图
- 渲染一个带边框的圆圈（`View` with `circle` style）
- 在圆圈内渲染可拖拽的方块（`Animated.View` with `square` style）
- 使用 `GestureDetector` 包裹方块以启用手势识别

### 6. **样式定义** (123-145 行)

- `container`：居中布局
- `square`：蓝色方块样式（`#4A8DDA`），带圆角
- `circle`：圆圈样式，带边框，用于显示拖拽边界

## 动画效果

1. **拖拽交互**：用户可以拖拽蓝色方块在屏幕上移动
2. **边界限制**：方块被限制在屏幕可见范围内
3. **自动回弹**：当方块在圆圈内释放时，使用弹性动画自动回到中心位置
4. **视觉反馈**：圆圈边框提供拖拽区域的视觉提示

## 关键实现细节

- **碰撞检测**：使用距离计算判断方块是否在圆圈内（`dist < maxAllowedDistance`）
- **位置限制**：使用 `clamp` 函数确保方块不会移出屏幕
- **平滑动画**：使用 `withSpring` 实现自然的弹性回弹效果
- **性能优化**：所有计算函数都标记为 `"worklet"`，在 UI 线程运行，保证 60fps 流畅度

## package

```json
{
  "react-native-gesture-handler": "~2.28.0",
  "react-native-worklets": "0.5.1",
  "react-native-reanimated": "~4.1.1"
}
```

## 源代码

```jsx title="expo"
import { Stack } from "expo-router";
import { Dimensions, StyleSheet, View } from "react-native";
import {
  Gesture,
  GestureDetector,
  GestureHandlerRootView,
} from "react-native-gesture-handler";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
} from "react-native-reanimated";

const SIZE = 100;
const CIRCLE_RADIUS = SIZE * 2;
const CIRCLE_VISIBLE_RADIUS = (CIRCLE_RADIUS * 1.5) / 2; // 圆圈的实际可视半径

const { width, height } = Dimensions.get("screen");

function clamp(val: number, min: number, max: number): number {
  "worklet";

  return Math.min(Math.max(val, min), max);
}

function distance(x: number, y: number): number {
  "worklet";
  return Math.sqrt(x ** 2 + y ** 2);
}

export default function Index() {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const prevTranslateX = useSharedValue(0);
  const prevTranslateY = useSharedValue(0);

  const panGesture = Gesture.Pan()
    .onStart((e) => {
      prevTranslateX.value = translateX.value;
      prevTranslateY.value = translateY.value;
    })
    .onUpdate((e) => {
      const maxTranslateX = width / 2 - SIZE / 2;
      const maxTranslateY = height / 2 - SIZE / 2;
      translateX.value = clamp(
        prevTranslateX.value + e.translationX,
        -maxTranslateX,
        maxTranslateX
      );
      translateY.value = clamp(
        prevTranslateY.value + e.translationY,
        -maxTranslateY,
        maxTranslateY
      );
    })
    .onEnd((e) => {
      const dist = distance(translateX.value, translateY.value);
      // 检查方块是否进入圆环内：方块中心距离 - 方块半径 < 圆环半径
      // 即：方块最近的边缘点距离圆圈中心 < 圆环半径时，方块就进入了圆环
      // 只要方块有任何部分在圆环内，释放后就归零
      const maxAllowedDistance = CIRCLE_VISIBLE_RADIUS + SIZE / 2;
      if (dist < maxAllowedDistance) {
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
      }
    });

  const rStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateX: translateX.value,
        },
        {
          translateY: translateY.value,
        },
      ],
    };
  });
  return (
    <>
      <Stack.Screen
        options={{
          headerShown: false,
        }}
      />
      <GestureHandlerRootView style={styles.container}>
        <View style={styles.circle}>
          <GestureDetector gesture={panGesture}>
            <Animated.View style={[styles.square, rStyle]} />
          </GestureDetector>
        </View>
      </GestureHandlerRootView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  square: {
    width: SIZE,
    height: SIZE,
    backgroundColor: "#4A8DDA",
    borderRadius: 16,
  },
  circle: {
    width: CIRCLE_RADIUS * 1.5,
    height: CIRCLE_RADIUS * 1.5,
    borderRadius: CIRCLE_RADIUS,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 4,
    borderColor: "#4A8DDA",
  },
});
```
